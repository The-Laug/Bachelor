method try()
{
    var n: Int
    assume n > 4
    var p: Int
    assume 0<p<n
 
    var s1: Multiset[Int]
    var s2: Multiset[Int]
    var s3: Multiset[Int]

    // s1 = 0 to n
    assume forall j:Int :: (0<=j<=n ==> (j in s1)==1)
    assume forall j:Int :: (j < 0) ==> (j in s1)==0  
    assume forall j:Int :: (j > n) ==> (j in s1)==0
    // s1 is the Multiset {0,1,...,n-1,n}

    // s2 = 0 to p
    assume forall j:Int :: (0<=j<=p ==> (j in s2)==1)
    assume forall j:Int :: (j < 0) ==> (j in s2)==0  
    assume forall j:Int :: (j > p) ==> (j in s2)==0
    // s2 is the Multiset {0,1,...p-1,p}



    // s3 = p to n
    assume forall j:Int :: (p<j<=n) ==> (j in s3)==1
    assume forall j:Int :: (j <= p) ==> (j in s3)==0  
    assume forall j:Int :: (j > n) ==> (j in s3)==0
    // s3 is the Multiset {p+1,p+2,...n-1,n}
 
    // assume forall j:Int :: 0<=j<=2*n ==> (j in s3)==1 // s1 is the Multiset {0,1,2,3,4,5}
    //assert Multiset(0,1,2) subset s1 // sanity checks
    //assert Multiset(0,1,2,3,4,5) subset s3 // sanity checks
    //assert Multiset(3) subset s1 // This fails
 
    assert s1 subset (s2 union s3)
    assert p>=1
    assert n>=2
    assert Multiset(1) subset s1
    assert (s2 union s3) subset s1
    // assert false

}